\chapter{RISC-V ZTernarybits Extension}
\label{tbits}

This chapter describes four additional bit manipulation instructions {\tt cmix}, {\tt cmov},
{\tt fsl}, and {\tt fsr} instructions that require three source operands. Those instruction
are not included in RISC-V Bitmanip because only instructions with one or two source operands are
included in the base Bitmanip spec for increased compatibility with existing RISC-V integer
pipelines.

All four instructions can be encoded in the same single minor opcode, for example in the
brownfield within the floating point fused-multiply-add instructions.

\section{Conditional mix ({\tt cmix})}

The {\tt cmix rd, rs1, rs2, rs3} instruction selects bits from {\tt rs1} and {\tt rs3} based
on the bits in the control word {\tt rs2}. It is equivalent to the following sequence.

\begin{verbatim}
  and rd, rs1, rs2
  andc t0, rs3, rs2
  or rd, rd, t0
\end{verbatim}

Using {\tt cmix} a single butterfly or stage can be implemented in only two
instructions. Thus, arbitrary bit-permutations can be implemented using only
18 instruction (32 bit) or 22 instructions (64 bits).

\input{bextcref-cmix}

\section{Conditional move ({\tt cmov})}

The {\tt cmov rd, rs1, rs2, rs3} instruction selects {\tt rs1} if the control
word {\tt rs2} is non-zero, and {\tt rs3} if the control word is zero.

\input{bextcref-cmov}

\section{Funnel shift ({\tt fsl}, {\tt fsr})}

The {\tt fsl rd, rs1, rs2, rs3} instruction creates a $2\cdot\textrm{XLEN}$ word
by concatenating rs1 and rs3 (with rs1 in the MSB half), rotate-left-shifts that
word by the amount indicated in the $log_2(\textrm{XLEN})+1$ LSB bits in rs2, and
then writes the MSB half of the result to rd.

The {\tt fsr rd, rs1, rs2, rs3} instruction creates a $2\cdot\textrm{XLEN}$ word
by concatenating rs1 and rs3 (with rs1 in the LSB half), rotate-right-shifts that
word by the amount indicated in the $log_2(\textrm{XLEN})+1$ LSB bits in rs2, and
then writes the LSB half of the result to rd.

\input{bextcref-fsl}

\input{bextcref-fsr}

A shift unit capable of either {\tt fsl} or {\tt fsr} is capable of performing all
the other shift functions, including the other funnel shift, with only minimal additional
logic.

For any values of {\tt A}, {\tt C}, and {\tt C}:

\begin{verbatim}
  fsl(A, B, C) = fsr(A, -B, C)
\end{verbatim}

And for any values {\tt x} and $0 \le \texttt{shamt} < \texttt{XLEN}$:

\begin{verbatim}
  sll(x, shamt) == fsl(x, shamt, 0)
  srl(x, shamt) == fsr(x, shamt, 0)
  sra(x, shamt) == fsr(x, shamt, sext_x)
  slo(x, shamt) == fsl(x, shamt, ~0)
  sro(x, shamt) == fsr(x, shamt, ~0)
  ror(x, shamt) == fsr(x, shamt, x)
  rol(x, shamt) == fsl(x, shamt, x)
\end{verbatim}
